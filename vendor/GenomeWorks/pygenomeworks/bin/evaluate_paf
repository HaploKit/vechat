#!/usr/bin/env python3

#
# Copyright 2019-2020 NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


"""Functions and tools for calculating the accuracy of overlap detection"""

import argparse
from collections import defaultdict

from genomeworks.io import pafio


def match_overlaps(query_0, query_1, target_0, target_1, pos_tolerance):
    """Given two sets of query and target ranges, check if the query and target ranges
    fall within a specified tolerance of each other.

    Args:
        query_0 (int, int) : Start/end locations for query_0
        query_1 (int, int) : Start/end locations of query_1
        target_0 (int, int): Start/end location of target_0
        target_1 (int, int): Start/end locations of target_1

    Returns: Boolean indicating query and target match.
    """

    query_start_valid = abs(query_0[0] - query_1[0]) < pos_tolerance
    query_end_valid = abs(query_0[1] - query_1[1]) < pos_tolerance
    target_start_valid = abs(target_0[0] - target_1[0]) < pos_tolerance
    target_end_valid = abs(target_0[1] - target_1[1]) < pos_tolerance

    match = query_start_valid and query_end_valid and target_start_valid \
        and target_end_valid

    return {"query_start_valid": query_start_valid,
            "query_end_valid": query_end_valid,
            "target_start_valid": target_start_valid,
            "target_end_valid": target_end_valid,
            "match": match}
    return match


def generate_key(name_1, name_2):
    """Given two read names, return key for indexing overlaps.

    Args:
        name_1 (str) : Name of first read
        name_2 (str): Name of second read

    Returns: a key of concatenated names.
    """
    return "{}_{}".format(name_1, name_2)


def evaluate_paf(truth_paf_filepath, test_paf_filepath, pos_tolerance=400, skip_self_mappings=True):
    """Given a truth and test set PAF file, count number of in/incorrectly detected, and non-detected overlaps
    Args:
       truth_paf_filepath (str): Path to truth set PAF file
       test_paf_filepath (str): Path to test set PAF file
       pos_tolerance (int): query and referennce positions within this range will be connsidered to be a matched overlap
       skip_self_mappings (bool: Skip overlaps where query and target ID are the same

    Returns: 3-tupe consisting of (rue_positive_count, false_positive_count, false_negative_count).
    """

    # Put the truth paf into a dictionary:
    truth_overlaps = defaultdict(list)

    num_true_overlaps = 0
    for truth_overlap in pafio.read_paf(truth_paf_filepath):
        if skip_self_mappings and \
                (truth_overlap.query_sequence_name == truth_overlap.target_sequence_name):
            continue

        key = generate_key(truth_overlap.query_sequence_name, truth_overlap.target_sequence_name)

        truth_overlaps[key].append(truth_overlap)
        num_true_overlaps += 1

    true_positive_count = 0
    false_positive_count = 0
    false_negative_count = 0

    print("{} true overlaps in truth set".format(num_true_overlaps))

    seen_test_overlap_keys = set()

    incorrect_query_start = 0
    incorrect_query_end = 0
    incorrect_target_start = 0
    incorrect_target_end = 0

    for test_overlap in pafio.read_paf(test_paf_filepath):
        if skip_self_mappings and \
                (test_overlap.query_sequence_name == test_overlap.target_sequence_name):
            continue

        query_0 = (test_overlap.query_start, test_overlap.query_end)
        target_0 = (test_overlap.target_start, test_overlap.target_end)

        key = generate_key(test_overlap.query_sequence_name, test_overlap.target_sequence_name)
        key_reversed = generate_key(test_overlap.target_sequence_name, test_overlap.query_sequence_name)

        if (key in seen_test_overlap_keys) or (key_reversed in seen_test_overlap_keys):
            continue

        seen_test_overlap_keys.add(key)
        seen_test_overlap_keys.add(key_reversed)

        found_match = False
        if key in truth_overlaps:
            for truth_overlap in truth_overlaps[key]:
                query_1 = (truth_overlap.query_start, truth_overlap.query_end)
                target_1 = (truth_overlap.target_start, truth_overlap.target_end)

                match_statistics = match_overlaps(query_0, query_1, target_0, target_1, pos_tolerance)

                incorrect_query_start += not match_statistics["query_start_valid"]
                incorrect_query_end += not match_statistics["query_end_valid"]
                incorrect_target_start += not match_statistics["target_start_valid"]
                incorrect_target_end += not match_statistics["target_end_valid"]

                if match_statistics["match"]:
                    true_positive_count += 1
                    found_match = True
                    break

        elif key_reversed in truth_overlaps:
            for truth_overlap in truth_overlaps[key_reversed]:
                query_1 = (truth_overlap.target_start, truth_overlap.target_end)
                target_1 = (truth_overlap.query_start, truth_overlap.query_end)

                match_statistics = match_overlaps(query_0, query_1, target_0, target_1, pos_tolerance)

                incorrect_query_start += not match_statistics["query_start_valid"]
                incorrect_query_end += not match_statistics["query_end_valid"]
                incorrect_target_start += not match_statistics["target_start_valid"]
                incorrect_target_end += not match_statistics["target_end_valid"]

                if match_statistics["match"]:
                    true_positive_count += 1
                    found_match = True
                    break

        if not found_match:
            false_positive_count += 1

    #  Now count the false negatives:
    false_negative_count = num_true_overlaps - true_positive_count

    # Return all the statistics
    return(true_positive_count,
           false_positive_count,
           false_negative_count,
           incorrect_query_start,
           incorrect_query_end,
           incorrect_target_start,
           incorrect_target_end)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Given a truth (reference) and test set of overlaps in PAF format,\
         calculate precision and recall")
    parser.add_argument('--truth_paf',
                        type=str,
                        default='truth.paf')
    parser.add_argument('--test_paf',
                        type=str,
                        default='test.paf')
    parser.add_argument('--pos_tolerance',
                        type=int,
                        default=400,
                        help="Position tolerance around truth set interval to count as successful match.")
    parser.add_argument('--skip_self_mapping',
                        action="store_true",
                        help="Skip checking overlaps where query/target name are same")

    args = parser.parse_args()

    true_positives, false_positives, false_negatives, incorrect_query_start, incorrect_query_end, incorrect_target_start, \
        incorrect_target_end = evaluate_paf(args.truth_paf, args.test_paf,
                                            args.pos_tolerance, args.skip_self_mapping)

    print("True positives: ", true_positives)
    print("False positives: ", false_positives)
    print("False negatives: ", false_negatives)
    print("Incorrect query starts:", incorrect_query_start)
    print("Incorrect target starts:", incorrect_target_start)
    print("Incorrect query ends:", incorrect_query_end)
    print("Incorrect target ends:", incorrect_target_end)

    precision = true_positives / (true_positives + false_positives)
    recall = true_positives / (true_positives + false_negatives)

    print("Precision = {}, Recall = {}".format(precision, recall))
